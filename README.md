# CC Parser

The attached project is the second step of simple compiler construction, that generates parse tree and symbol table after parsing a simple custom language.

## About .cc Language

A new yet simple custom made language is taken as an example which uses constructs from some of the most popular languages in use today. The task is to develop a lexical analyzer for this language.  
A brief description of the main features of this language is as follow:

1. **Data types:** int, char
2. **Keywords:**  
    • **Decision statement:** if, elif, else  
    • **Looping statement:** while  
    • **Standart input statement:** input  
    • **Standard output statement:** print (print and remain on same line), println (print and move to next line)  
3. **Arithmetic operators:** + - * /
4. **Relational operators:** < <= > >= == ~=
5. **Comments:**  
    • **Single line comment:** // comment  
    • **Multi  line comment:** /* comment */
6. **Identifier:** a letter followed by any number of letters, digits or the underscore symbol
7. **Numeric constants:** only integers
8. **Literal constants:** only a single letter enclosed in single quotes
9. **Strings:** sequence of characters and white spaces enclosed in double quotes
10. **Parenthesis, Braces, Square Brackets**
11. **Assignment Operator:** =
12. **Input Operators:** ->
13. **Semi-Colon, Colon, Comma**

### Sample Code

``` 
int: num;
char: my_char;
// lets assign variable my_char a value
my_char = 'd';
print("my char contains: ");
println(my_char);
/*
The program here onwards is an iterative algorithm
for fibonacci numbers
*/
println("enter a number");
input -> num;
int: a = 0, b=1, c=0;
println("The fibonacci seq is: ");
println(a);
println(b);
while c <= num:
{
int: temp = a+b;
a = b;
b = temp;
println(temp);
c++;
}
```

## Getting Started

The Parser will take the file ```tokens.txt``` generated by the Lexer and analyze its syntax according to the grammar designed for the given language. In the case of incorrect syntax, it will halt execution and print an appropriate error message. In the case of completely correct syntax, it will produce a parse tree ```parsetree.txt``` of the code. It implements the following grammar:

Start --> Statements  
Statements --> Statement Statements | ^  
Statement --> if Condition : { Statements } ElifOrElse  
| while Condition : { Statements }  
| print ( OutputOptions ) ; | println ( OutputOptions ) ;  
| ID (IncOp | DecOp) ;  
| VariableInput  
| Variable  
| AssignmentStatement  
| S_COMMENT | M_COMMENT  
Expression --> Term R  
R --> + Term R | - Term R | ^  
Term --> Factor R_  
R_ --> * Factor R_ | / Factor R_ | ^  
Factor --> ID | NUM | ( Expression )  
Condition --> Expression relOp Expression  
ElifOrElse --> elif Condition : { Statements } ElifOrElse | Else  
Else --> else { Statements } | ^  
OutputOptions --> ID | NUM | LIT | STR | Expression  
IncOp --> ++  
DecOp --> --  
VariableInput --> input INPUT_OP ID inputDelimiter  
inputDelimiter --> ; | , nextInput  
nextInput --> ID inputDelimiter  
Variable --> DT : ID optionAssign VariableDelimiter  
VariableDelimiter --> ; | , nextVariable  
nextVariable --> ID optionAssign VariableDelimiter  
AssignmentStatement --> ID assignOp Value ;  
Value --> ID | NUM | LIT | Expression  

The following are some test cases and sample output of the code:

#### Wrong Input

sample_code.cc  | Output
-------------   | -------------
// lets start<br>int: a = 0 b=5;<br>while a<= b:<br>{<br>println(a);<br>a++;<br>}  |  Lexer execution successful! Check the generated tokens in tokens.txt<br>Syntax error at line 2<br>2&emsp;&emsp;&emsp;int: a = 0 b=5;<br>Review your code and try again

#### Correct Input

sample_code.cc  | Output
-------------   | -------------
// lets start<br>int: a = 0, b=5;<br>while a<= b:<br>{<br>println(a);<br>a++;<br>}  |  Start<br>==> Statements<br>==>==> Statement<br>==>==>==> S_COMMENT<br>==>==> Statements<br>==>==>==> Statement<br>==>==>==>==> Variable<br>==>==>==>==>==> DT<br>==>==>==>==>==>==> int<br>==>==>==>==>==> :<br>==>==>==>==>==> ID(a)<br>==>==>==>==>==>==> =<br>==>==>==>==>==>==> Value<br>==>==>==>==>==>==>==> NUM(0)<br>==>==>==>==>==> VariableDelimiter<br>==>==>==>==>==>==> ,<br>==>==>==>==>==>==> nextVariable<br>==>==>==>==>==>==>==> ID(b)<br>==>==>==>==>==>==>==>==> =<br>==>==>==>==>==>==>==>==> Value<br>==>==>==>==>==>==>==>==>==> NUM(5)<br>==>==>==>==>==>==>==> VariableDelimiter<br>==>==>==>==>==>==>==>==> ;<br>==>==>==> Statements<br>==>==>==>==> Statement<br>==>==>==>==>==> WHILE<br>==>==>==>==>==> Condition<br>==>==>==>==>==>==> Expression<br>==>==>==>==>==>==>==> Term<br>==>==>==>==>==>==>==>==> Factor<br>==>==>==>==>==>==>==>==>==> ID(a)<br>==>==>==>==>==>==>==>==> R_<br>==>==>==>==>==>==>==>==>==> ^<br>==>==>==>==>==>==>==> R<br>==>==>==>==>==>==>==>==> ^<br>==>==>==>==>==>==> relOp<br>==>==>==>==>==>==>==>relOp(LE)<br>==>==>==>==>==>==> Expression<br>==>==>==>==>==>==>==> Term<br>==>==>==>==>==>==>==>==> Factor<br>==>==>==>==>==>==>==>==>==> ID(b)<br>==>==>==>==>==>==>==>==> R_<br>==>==>==>==>==>==>==>==>==> ^<br>==>==>==>==>==>==>==> R<br>==>==>==>==>==>==>==>==> ^<br>==>==>==>==>==> :<br>==>==>==>==>==> {<br>==>==>==>==>==> Statements<br>==>==>==>==>==>==> Statement<br>==>==>==>==>==>==>==> PRINTLN<br>==>==>==>==>==>==>==> (<br>==>==>==>==>==>==>==> OutputOptions<br>==>==>==>==>==>==>==>==> ID(a)<br>==>==>==>==>==>==>==> )<br>==>==>==>==>==>==>==> ;<br>==>==>==>==>==>==> Statements<br>==>==>==>==>==>==>==> Statement<br>==>==>==>==>==>==>==>==> IncOp<br>==>==>==>==>==>==>==>==>==> ID(a)<br>==>==>==>==>==>==>==>==>==> +<br>==>==>==>==>==>==>==>==>==> +<br>==>==>==>==>==>==>==>==>==> ;<br>==>==>==>==>==>==>==> Statements<br>==>==>==>==>==>==>==>==> ^<br>==>==>==>==>==> }<br>==>==>==>==> Statements<br>==>==>==>==>==> ^

The Parser also produces a file ```parser-symboltable.txt``` which includes information about the scope, the identifiers and their datatype.

#### Output of Program

sample_code.cc  | parsetree.txt | parser-symboltable.txt
-------------   | ------------- | -------------
// lets start<br>int: a = 0, b=5;<br>while a<= b:<br>{<br>println(a);<br>a++;<br>}  |  Start<br>==> Statements<br>==>==> Statement<br>==>==>==> S_COMMENT<br>==>==> Statements<br>==>==>==> Statement<br>==>==>==>==> Variable<br>==>==>==>==>==> DT<br>==>==>==>==>==>==> int<br>==>==>==>==>==> :<br>==>==>==>==>==> ID(a)<br>==>==>==>==>==>==> =<br>==>==>==>==>==>==> Value<br>==>==>==>==>==>==>==> NUM(0)<br>==>==>==>==>==> VariableDelimiter<br>==>==>==>==>==>==> ,<br>==>==>==>==>==>==> nextVariable<br>==>==>==>==>==>==>==> ID(b)<br>==>==>==>==>==>==>==>==> =<br>==>==>==>==>==>==>==>==> Value<br>==>==>==>==>==>==>==>==>==> NUM(5)<br>==>==>==>==>==>==>==> VariableDelimiter<br>==>==>==>==>==>==>==>==> ;<br>==>==>==> Statements<br>==>==>==>==> Statement<br>==>==>==>==>==> WHILE<br>==>==>==>==>==> Condition<br>==>==>==>==>==>==> Expression<br>==>==>==>==>==>==>==> Term<br>==>==>==>==>==>==>==>==> Factor<br>==>==>==>==>==>==>==>==>==> ID(a)<br>==>==>==>==>==>==>==>==> R_<br>==>==>==>==>==>==>==>==>==> ^<br>==>==>==>==>==>==>==> R<br>==>==>==>==>==>==>==>==> ^<br>==>==>==>==>==>==> relOp<br>==>==>==>==>==>==>==>relOp(LE)<br>==>==>==>==>==>==> Expression<br>==>==>==>==>==>==>==> Term<br>==>==>==>==>==>==>==>==> Factor<br>==>==>==>==>==>==>==>==>==> ID(b)<br>==>==>==>==>==>==>==>==> R_<br>==>==>==>==>==>==>==>==>==> ^<br>==>==>==>==>==>==>==> R<br>==>==>==>==>==>==>==>==> ^<br>==>==>==>==>==> :<br>==>==>==>==>==> {<br>==>==>==>==>==> Statements<br>==>==>==>==>==>==> Statement<br>==>==>==>==>==>==>==> PRINTLN<br>==>==>==>==>==>==>==> (<br>==>==>==>==>==>==>==> OutputOptions<br>==>==>==>==>==>==>==>==> ID(a)<br>==>==>==>==>==>==>==> )<br>==>==>==>==>==>==>==> ;<br>==>==>==>==>==>==> Statements<br>==>==>==>==>==>==>==> Statement<br>==>==>==>==>==>==>==>==> IncOp<br>==>==>==>==>==>==>==>==>==> ID(a)<br>==>==>==>==>==>==>==>==>==> +<br>==>==>==>==>==>==>==>==>==> +<br>==>==>==>==>==>==>==>==>==> ;<br>==>==>==>==>==>==>==> Statements<br>==>==>==>==>==>==>==>==> ^<br>==>==>==>==>==> }<br>==>==>==>==> Statements<br>==>==>==>==>==> ^  |  SCOPE START<br>a	INT<br>b	INT<br>SCOPE START<br>SCOPE END<br>SCOPE END

### Before you Start

This program is made and tested in **java version 14 2020-03-17**. So, you should have **Java JDK 14** installed on your system.

## How to Build and Run

In src folder, enter the following commands to compile the code. Necessary binary files will be produced with ```.class``` extention.  
```javac lexer/Lexer.java```  
```javac parser/Parser.java```  
```javac Source.java```  

To run this program, enter the following in src folder:  
```java Source sample_code.cc```